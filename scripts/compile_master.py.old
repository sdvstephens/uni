#!/usr/bin/env python3
"""
Standalone Master Compiler - Works with existing lecture files
No changes to your current workflow or scripts!

Usage:
  python3 compile_master.py Abstract_Algebra
  python3 compile_master.py Abstract_Algebra --open
"""

import os
import sys
import subprocess
import argparse
from pathlib import Path

class MasterCompiler:
    def __init__(self, root_dir="~/university"):
        self.root_dir = Path(root_dir).expanduser()
    
    def find_preamble(self):
        """Find preamble.tex location"""
        # Check common locations
        locations = [
            self.root_dir / "preamble.tex",
            Path.home() / ".config/latex/preamble.tex",
            Path.cwd() / "preamble.tex",
        ]
        
        for loc in locations:
            if loc.exists():
                return loc
        return None
    
    def extract_content(self, lecture_file):
        """Extract content from standalone lecture file (strip documentclass and preamble)"""
        with open(lecture_file, 'r') as f:
            lines = f.readlines()
        
        # Find where actual content starts (after \begin{document})
        content_start = 0
        content_end = len(lines)
        in_document = False
        
        for i, line in enumerate(lines):
            if '\\begin{document}' in line:
                content_start = i + 1
                in_document = True
            elif '\\end{document}' in line and in_document:
                content_end = i
                break
        
        # Extract only the content between \begin{document} and \end{document}
        content = ''.join(lines[content_start:content_end])
        return content.strip()
    
    def compile_course(self, course_name, open_pdf=False, preamble_path="../preamble.tex", strip_mode=True):
        """Compile all lectures in a course into master.pdf"""
        course_path = self.root_dir / course_name
        
        # Validate course directory exists
        if not course_path.exists():
            print(f"‚ùå Course directory not found: {course_path}")
            print(f"Available courses:")
            self.list_courses()
            return False
        
        # Check for preamble
        preamble_path = self.find_preamble()
        if not preamble_path:
            print(f"‚ö†Ô∏è  Warning: preamble.tex not found in common locations")
            print(f"   Checked: {self.root_dir}/preamble.tex")
            print(f"   The master.tex will assume ../preamble.tex")
            response = input("   Continue anyway? (y/n): ")
            if response.lower() != 'y':
                return False
        
        # Find all lecture files (handles both flat and lectures/ subdirectory)
        lecture_files = []
        
        # Check flat structure (lecture_01.tex in course root)
        flat_lectures = sorted(course_path.glob("lecture_*.tex"))
        
        # Check lectures/ subdirectory
        lectures_dir = course_path / "lectures"
        subdir_lectures = []
        if lectures_dir.exists():
            subdir_lectures = sorted(lectures_dir.glob("lecture_*.tex"))
        
        # Use whichever has files
        if flat_lectures:
            lecture_files = flat_lectures
            lectures_relative = ""  # No subdirectory
        elif subdir_lectures:
            lecture_files = subdir_lectures
            lectures_relative = "lectures/"
        else:
            print(f"‚ùå No lecture files found in {course_path}")
            print(f"Looking for: lecture_01.tex, lecture_02.tex, etc.")
            return False
        
        print(f"üìö Found {len(lecture_files)} lectures in {course_name}")
        
        if strip_mode:
            # Extract content from standalone lecture files
            print(f"üìù Extracting content from standalone lecture files...")
            extracted_lectures = []
            for lecture_file in lecture_files:
                content = self.extract_content(lecture_file)
                extracted_lectures.append({
                    'name': lecture_file.stem,
                    'content': content
                })
            
            # Generate master.tex with extracted content
            master_content = self.generate_master_tex_embedded(
                course_name,
                extracted_lectures,
                preamble_path
            )
        else:
            # Use \input statements (for content-only lecture files)
            master_content = self.generate_master_tex(
                course_name, 
                lecture_files, 
                lectures_relative,
                preamble_path
            )
        
        # Write master.tex
        master_file = course_path / "master.tex"
        with open(master_file, 'w') as f:
            f.write(master_content)
        print(f"‚úì Generated {master_file}")
        
        # Compile to PDF
        print(f"üî® Compiling master.pdf...")
        success = self.compile_latex(course_path)
        
        if success:
            print(f"‚úÖ Successfully created master.pdf")
            
            # Open PDF if requested
            if open_pdf:
                pdf_file = course_path / "master.pdf"
                if pdf_file.exists():
                    self.open_pdf(pdf_file)
            
            return True
        else:
            print(f"‚ùå Compilation failed. Check master.log for errors.")
            return False
    
    def generate_master_tex(self, course_name, lecture_files, lectures_relative, preamble_path="../preamble.tex"):
        """Generate master.tex content"""
        
        # Generate \input statements for each lecture
        input_lines = []
        for lecture in lecture_files:
            # Strip .tex extension for \input
            lecture_name = lecture.stem
            input_lines.append(f"\\input{{{lectures_relative}{lecture_name}.tex}}")
        
        inputs = "\n".join(input_lines)
        
        # Master template
        template = f"""\\documentclass[12pt,oneside]{{report}}

% Load preamble
\\input{{{preamble_path}}}

% Optional: Customize these
\\course{{{course_name}}}
\\me{{Your Name}}

\\begin{{document}}

% Title page
\\begin{{titlepage}}
    \\centering
    \\vspace*{{2cm}}
    {{\\Huge\\bfseries {course_name}\\par}}
    \\vspace{{1cm}}
    {{\\Large Lecture Notes\\par}}
    \\vspace{{2cm}}
    {{\\Large Compiled: \\today\\par}}
\\end{{titlepage}}

% Table of contents
\\tableofcontents
\\newpage

\\pagestyle{{head}}

% All lectures
{inputs}

\\end{{document}}
"""
        return template
    
    def generate_master_tex_embedded(self, course_name, extracted_lectures, preamble_path="../preamble.tex"):
        """Generate master.tex with embedded lecture content (for standalone lecture files)"""
        
        # Build lecture content sections
        lecture_sections = []
        for lec in extracted_lectures:
            separator = "% " + "="*60
            section = f"{separator}\n% {lec['name']}\n{separator}\n\n{lec['content']}"
            lecture_sections.append(section)
        
        all_content = "\n\n".join(lecture_sections)
        
        # Master template with embedded content
        template = f"""\\documentclass[12pt,oneside]{{report}}

% Load preamble
\\input{{{preamble_path}}}

% Optional: Customize these
\\course{{{course_name.replace('_', ' ')}}}
\\me{{Your Name}}

\\begin{{document}}

% Title page
\\begin{{titlepage}}
    \\centering
    \\vspace*{{2cm}}
    {{\\Huge\\bfseries {course_name.replace('_', ' ')}\\par}}
    \\vspace{{1cm}}
    {{\\Large Lecture Notes\\par}}
    \\vspace{{2cm}}
    {{\\Large Compiled: \\today\\par}}
\\end{{titlepage}}

% Table of contents
\\tableofcontents
\\newpage

\\pagestyle{{head}}

% ============================================
% ALL LECTURES (content extracted)
% ============================================

{all_content}

\\end{{document}}
"""
        return template
    
    def compile_latex(self, course_path):
        """Compile master.tex to PDF"""
        original_dir = os.getcwd()
        os.chdir(course_path)
        
        try:
            # Run pdflatex twice (for TOC and cross-references)
            for i in range(2):
                result = subprocess.run(
                    ["pdflatex", "-interaction=nonstopmode", "master.tex"],
                    capture_output=True,
                    text=True
                )
                if result.returncode != 0:
                    print(f"‚ùå pdflatex error (run {i+1}/2)")
                    return False
            
            return True
            
        except FileNotFoundError:
            print("‚ùå pdflatex not found. Make sure LaTeX is installed.")
            return False
        except Exception as e:
            print(f"‚ùå Error during compilation: {e}")
            return False
        finally:
            os.chdir(original_dir)
    
    def open_pdf(self, pdf_file):
        """Open PDF in default viewer"""
        try:
            if sys.platform == "darwin":  # macOS
                subprocess.run(["open", str(pdf_file)])
            elif sys.platform == "linux":
                subprocess.run(["xdg-open", str(pdf_file)])
            elif sys.platform == "win32":
                os.startfile(str(pdf_file))
        except Exception as e:
            print(f"Could not open PDF: {e}")
    
    def list_courses(self):
        """List available courses in university directory"""
        if not self.root_dir.exists():
            print(f"‚ùå Root directory not found: {self.root_dir}")
            return
        
        # Find directories that contain lecture files
        courses = []
        for item in self.root_dir.iterdir():
            if item.is_dir() and not item.name.startswith('.'):
                # Check for lecture files
                has_flat = list(item.glob("lecture_*.tex"))
                has_subdir = list((item / "lectures").glob("lecture_*.tex")) if (item / "lectures").exists() else []
                
                if has_flat or has_subdir:
                    lecture_count = len(has_flat or has_subdir)
                    courses.append((item.name, lecture_count))
        
        if courses:
            print("\nAvailable courses:")
            for name, count in sorted(courses):
                print(f"  ‚Ä¢ {name} ({count} lectures)")
        else:
            print(f"\nNo courses with lecture files found in {self.root_dir}")
    
    def clean(self, course_name):
        """Clean auxiliary LaTeX files"""
        course_path = self.root_dir / course_name
        
        if not course_path.exists():
            print(f"‚ùå Course not found: {course_name}")
            return
        
        # LaTeX auxiliary files
        aux_extensions = ['.aux', '.log', '.toc', '.out', '.synctex.gz']
        
        for ext in aux_extensions:
            for file in course_path.glob(f"master{ext}"):
                file.unlink()
                print(f"üóëÔ∏è  Deleted {file.name}")
        
        print("‚úì Cleaned auxiliary files")

def main():
    parser = argparse.ArgumentParser(
        description="Compile lecture notes into master.pdf",
        epilog="Example: python3 compile_master.py Abstract_Algebra --open"
    )
    
    parser.add_argument(
        "course",
        nargs="?",
        help="Course name (e.g., Abstract_Algebra)"
    )
    
    parser.add_argument(
        "--open", "-o",
        action="store_true",
        help="Open PDF after compilation"
    )
    
    parser.add_argument(
        "--list", "-l",
        action="store_true",
        help="List available courses"
    )
    
    parser.add_argument(
        "--clean", "-c",
        action="store_true",
        help="Clean auxiliary files"
    )
    
    parser.add_argument(
        "--root",
        default="~/university",
        help="Root university directory (default: ~/university)"
    )
    
    parser.add_argument(
        "--preamble", "-p",
        default="../preamble.tex",
        help="Path to preamble.tex relative to course directory (default: ../preamble.tex)"
    )
    
    parser.add_argument(
        "--no-strip",
        action="store_true",
        help="Don't strip documentclass/preamble (use if lectures are content-only)"
    )
    
    args = parser.parse_args()
    compiler = MasterCompiler(args.root)
    
    # List courses
    if args.list:
        compiler.list_courses()
        return
    
    # Clean files
    if args.clean:
        if not args.course:
            print("‚ùå Course name required for --clean")
            return
        compiler.clean(args.course)
        return
    
    # Compile course
    if not args.course:
        print("‚ùå Course name required")
        print("\nUsage:")
        print("  python3 compile_master.py Abstract_Algebra")
        print("  python3 compile_master.py --list")
        compiler.list_courses()
        return
    
    strip_mode = not args.no_strip  # Default is to strip
    compiler.compile_course(args.course, args.open, args.preamble, strip_mode)

if __name__ == "__main__":
    main()
